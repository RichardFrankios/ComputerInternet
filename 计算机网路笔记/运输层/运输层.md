# 1. 概述
- 运输层向它上面的应用层提供通信服务.它属于通信部分的最高层. 同时也是用户功能中的最底层.

- 运输层提供端到端的通信 : **通信的真正端点不是主机而是主机中的进程, 也就是说端到端的通信其实就是引用进程之间的通信.**
- 运输层有一个很重要的功能就是**复用和分用**
	- **复用 :** 发送方不同的应用进程都可以使用同一个传输层协议.
	- **分用 :** 接收方在接收到报文后剥去首部, 可以将这些报文准确地交给对应的应用进程.
- **运输层提供了应用进程之间的逻辑通信, 就好像是发送方和接收方的运输层之间在通信一样.但是实际上数据传输是经过很多层协议的**
![](http://i.imgur.com/Lm7XlKd.png)

- **网络层**提供了**主机**之间的逻辑通信. **运输层**提供了**应用进程**间的逻辑通信.
![](http://i.imgur.com/Z3ePwOe.png)
- **运输层**还要对收到的报文进行**差错检测**, 但是在**网络层**中的IP数据报首部的校验和只是对IP首部数据进行了校验, 没有检验数据部分.
- 当运输层采用面向连接的**TCP协议**时, 尽管下面的网络是不可靠的, 但是这种逻辑通信信道相当于**一条全双工可靠信道**. 当运输层采用**无连接的UDP协议**时, 这条信道任然是**不可靠信道**.

### 1.1 运输层的两个主要协议
- **用户数据报协议UDP(User Datagram Protocol)**
- **传输控制协议TCP(Transmission Control Protocol)**

> 两个对等运输实体通信时传输的数据单元称为**运输协议数据单元TPDU(Transport Protocol Data Unit)**, 在TCP/IP体系中使用TCP协议称为**TCP报文段**, 使用UDP协议称为**UDP用户数据报**.

1. UDP在传输之前**不需要事先建立连接**, 远程主机的运输层在收到的UDP报文后.不需要给出任何确认.
2. TCP则提供**面向连接的服务**, 传输数据之前需要事先建立连接. 数据传输结束后需要释放连接. TCP不需要提供多播或者广播服务.


### 1.2 运输层端口

为了识别不同的应用程序在运输层使用了**协议端口号(Protocol Port Number)**, 简称端口.

注意 : 在协议栈层间抽象的协议端口是软件端口. 和路由器或交换机上的硬件端口是完全不同的概念.
- 硬件端口是不同硬件设备之间进行交会的接口.
- 软件端口是应用层的各协议进程与运输实体进行层间交互的一种地址.

TCP/IP的运输层使用一个16位端口号来标志一个端口(最大值 65535). 

**端口号共分为两大类**
- **服务器端使用的端口号 :** 又分了两类
	- 熟知端口号/系统端口号 : 一些重要的应用程序 0~1023
	![](http://i.imgur.com/tAVI3r6.png)
	- 登记端口号 : 1024~49151 需要手动 登记.
- **客户端使用的端口号 :** 49152~65535


# 2. 用户数据报协议 UDP

## 2.1 UDP的主要特点
- UDP 是无连接的. 也就是通信之前不需要建立连接.
- UDP 使用尽最大努力交付, 也就是不保证可靠交付.
- UDP 是面向报文的.发送方UDP对应用程序交下来的报文, 在添加了首部以后就直接交付IP层.UDP对应用下发的报文既不合并也不拆分.
![](http://i.imgur.com/MMs62XH.png)
- UDP 没有阻塞控制.
- UDP 支持一对一, 一对多, 多对一, 多对多的交互通信.
- UDP 首部开销小, 只有8字节.

## 2.2 UDP的首部格式

![](http://i.imgur.com/F3VF5Qx.png)


用户数据报UDP有两部分组成 : **首部字段(8字节) 和 数据字段**

- **UDP首部有四个字段组成**
	- **源端口 :** 源端口号, 在需要对方回应时使用, 不需要回应时可以全部写0.
	- **目的端口 :** 目的端口号, 这在终点交付报文时必须要使用到.
	- **长度 :** UDP用户数据报长度, 其最小值是 8 (仅有首部).
	- **校验和 :** 检测UDP用户数据报在传输过程中是否有错, 有错就丢弃.

> UDP的校验和是将对 "伪首部" + "首部" + "数据" 三部分进行性校验. 对于伪首部中第三个字段 全是 0 , 第四个字段是协议类型(UDP, 17); 第五个字段是用户数据报长度.

# 3. 传输控制协议 TCP
## 3.1 TCP的主要特点
- TCP是面向连接的运输协议.
- 每一条TCP只能有两个端点.
- TCP提供**可靠交付**的服务.
- TCP提供 **全双工通信**
- TCP是面向**字节流**的.
- TCP连接的是两个端点, 这两个端点是Socket(IP地址:端口号)

## 3.2 可靠传输的工作原理
### 3.2.1 停止等待协议
![](http://i.imgur.com/nQQM4iu.png)

- 无差错情况 : 图 a
- 出现差错情况 : 图 b. B 收到 M1报文发现是错误的就直接丢弃. 也不会给A任何响应. 等待一段时间后A就会进行**超时重传**.实现超时重传需要注意一下三点:
	- A发送完一个分组后, 必须保留该分组的副本.
	- 分组和确认分组都必须要进行编号.
	- 超时计时器设置的时间应该比数据分组传输的平均往返时间更长一些.
### 3.2.2 确认丢失和确认迟到
![](http://i.imgur.com/BburXyz.png)

像上面这样的自动重传的的协议称为自动重传请求ARQ.

### 3.2.3 信道利用率(流水线)

![](http://i.imgur.com/67h3R9P.png)

### 3.2.4 连续ARQ. 滚动窗口

## 3.3 TCP报文段首部格式.
![](http://i.imgur.com/x1lvm6M.png)

- **源端口和目的端口 :**各占 2字节, 分别写入源端口号和目的端口号.
- **序号 :** 占 4字节. 序号是 mod 2 ^32 运算的.TCP是面向字节流的. 在一个TCP连接传送的字节流中每一个字节都是按顺序编号的. 整个要传送的字节流序号必须在TCP建立连接时确定. 首部中的序号是指本报文段所发送的数据中第一个字节的序号.
- **确认号 :**占 4字节. 期望收到对方下一个报文段的第一个数据的序号. **如果确认号 = N, 则说明到序号N-1为止的所有数据都已经收到了.**
- **数据偏移** 数据报中数据距离报文开始的偏移量. 也就是**首部的长度** 他的单位是 4字节. 最大值是60字节. 
- 保留 6位
- **URG** = 1时表明紧急指针有效.
- **确认ACK :** 仅当 ACK=1时确认字段才有效. 当ACK=0时确认号无效.TCP规定, 在连接建立后所有的ACK都必须设置为 1;
- **推送PSH :** 当两个应用进行交互式通信时, 有时在一段的应用程序希望键入一个命令后立即得到响应, 这种情况下可以使用PSH方式.
- **复位RST :**当RST= 1时 表明TCP连接出现严重错误, 必须立即释放连接.然后重新建立连接.RST置 1,还用来拒绝一个非法的报文端.
- **同步SYN :**在连接建立时用来同步连接信号.当SYN=1 而 ACK=0 时, 表明这是一个连接请求报文段.若对方统一建立连接则应在报文段中使SYN= 1 , ACK= 1; 因此SYN = 1 表示这是一个连接请求或连接接受报文.
- **终止FIN :** FIN=1 ,表示次报文段的发送方已经发送完成. 请求释放连接.
- **窗口** 占 2字节. 接收窗口.单位是字节.
- **检验和 :** 合UDP一样. TCP, 6
- **紧急指针 :** 占2字节.
- **选项 :** 最大40字节.


## 3.4 TCP连接管理

#### 3.4.1 TCP建立连接, 三次无握手.

![](http://i.imgur.com/iFkAVXr.png)

- B的TCP服务器进程先创建传输控制块TCB, 准备接收客户端的连接请求.然后服务器就进入了**LISTEN** 状态.
- (第一次)A的TCP 客户端也是首先创建传输控制块TCB, 然后向B发出连接请求报文段.(SYN=1, ACK=0, seq=x), 同时他为自己选择了一个初始序号x. TCP规定 SYN = 1, 报文段不能携带数据.但是需要消耗要给序号.这是TCP 客户端进入到了 **SYN-SEND同步已发送**状态.
- (第二次)B收到连接请求报文后, 如果同意建立连接.则向A发送确认报文.在确认报文中设置 SYN=1, 报文段的ACK=1,同时选择自己的初始序号 seq = y, 确认号 ack = x + 1; 这个报文同样不能携带数据,  需要消耗一个序号.此时TCP服务器进入**SYN-REVD同步收到**状态. 
- (第三次)TCP客户端收到B的确认后, 还要向B给出确认.去人报文的SYN = 0; ACK=1;确认号ack = y + 1;而自己的序列号是seq=x+1;ACK 报文段可以携带哦数据.但是如果不携带数据则不消耗序号, 这样的话下一个报文段还是seq=x+1; 这是TCP连接已经建立 A进入**ESTABLISHED已建立连接**;
- 当B收到A的确认后也进入了 **ESTABLISHED已建立连接**.


#### 3.4.2 TCP连接释放

![](http://i.imgur.com/dqAq6pk.png)

- (第一次)A的应用进程先向其TCP发出连接释放报文.并且停止再次发送数据, 主动关闭TCP连接.A设置连接释放报文的首部FIN=1;序号 seq=u , u表示前面所有接收到的数据的最后一个字节的序号 + 1;这是A就进入**FIN-WAIT1(终止等待1)**状态.FIN报文即使不携带数据也要消耗一个序号.
- (第二次)B收到释放报文后立即发出确认报文.确认号 ack = u + 1;seq = v;然后B就进入了**CLOSE-WAIT(关闭等待)**状态.此时A到B方向的连接就已经释放了. 此时B任然可以向A发送数据.
- (第三次)A收到来自B的确认后就进入**FIN-WAIT2(终止等待2)**状态.
- (第四次)如果B没有数据要往A发送了,就会发出连接释放报文 FIN=1;ack还是和上次一样, ;之后B就进入了**LAST-ACK(最后确认状态)**;
- A收到报文后需要经ACK=1;seq=u+1;ack=w+1;然后就进入**TIME-WAIT(时间等待)**状态.时间等待计时器设置为2MSL后, A才进入**CLOSE**状态. 理论值 MSL=2分钟. 也就是4分钟后才会关闭.

> **保活计时器** 如果客户端与服务器已经建立了TCP连接.但是客户端主机突然出了故障.服务器就不能接收到客户端发来的数据.因此为了不让服务器白白等下去.就是用了保活计数器.如果一段时间客户端不发消息.则服务器发送试探数据报, 如果客户端在指定的时间内没有回复则断开连接.


#### 3.4.3 TCP有限状态机

![](http://i.imgur.com/zby4Rwa.png)
















